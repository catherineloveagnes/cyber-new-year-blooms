<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é™¤å¤•èµ›åšçƒŸèŠ± - Cyber New Year Blooms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a1a;
            font-family: 'STKaiti', 'KaiTi', 'æ¥·ä½“', serif;
        }

        #canvas {
            display: block;
            background: radial-gradient(ellipse at bottom, #0f173a 0%, #000814 100%);
        }

        .blessing-input {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        #blessingText {
            padding: 10px 20px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            background: rgba(0, 20, 50, 0.8);
            color: #ffd700;
            border-radius: 20px;
            font-size: 14px;
            outline: none;
            font-family: 'STKaiti', 'KaiTi', 'æ¥·ä½“', serif;
        }

        #blessingText::placeholder {
            color: rgba(255, 215, 0, 0.4);
        }

        #sendButton {
            padding: 10px 20px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid rgba(255, 215, 0, 0.4);
            color: #ffd700;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'STKaiti', 'KaiTi', 'æ¥·ä½“', serif;
            transition: all 0.3s;
        }

        #sendButton:hover {
            background: rgba(255, 215, 0, 0.3);
        }

        .qr-hint {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 215, 0, 0.6);
            font-size: 12px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="qr-hint">
        æ‰«ç å‘é€ç¥ç¦ â†’ å¸æ”¶è¿›çƒŸèŠ±
    </div>

    <div class="blessing-input">
        <input type="text" id="blessingText" placeholder="è¾“å…¥ç¥ç¦..." maxlength="20">
        <button id="sendButton">ç‚¹ç‡ƒ</button>
    </div>

    <script>
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(other) {
                this.x += other.x;
                this.y += other.y;
                return this;
            }

            sub(other) {
                this.x -= other.x;
                this.y -= other.y;
                return this;
            }

            mult(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            }

            dist(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }

            clone() {
                return new Vector2(this.x, this.y);
            }
        }

        class Particle {
            constructor(x, y, color, velocity, lifespan = 100, size = null) {
                this.pos = new Vector2(x, y);
                this.vel = velocity;
                this.color = color;
                this.lifespan = lifespan;
                this.maxLifespan = lifespan;
                this.opacity = 1;
                this.size = size || (Math.random() * 2 + 1);
            }

            update() {
                this.vel.y += 0.2; // é‡åŠ›
                this.vel.mult(0.98); // ç©ºæ°”é˜»åŠ›
                this.pos.add(this.vel);
                this.lifespan--;
                this.opacity = this.lifespan / this.maxLifespan;
            }

            draw(ctx) {
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            isDead() {
                return this.lifespan <= 0;
            }
        }

        class TextParticle extends Particle {
            constructor(x, y, text, fontSize = 20) {
                const color = `rgba(255, ${200 + Math.random() * 55}, ${Math.random() * 100}, 1)`;
                super(x, y, color, new Vector2(0, 0), 200);
                this.text = text;
                this.fontSize = fontSize;
                this.targetPos = new Vector2(x, y);
                this.formProgress = 0;
                this.charIndex = 0;
                this.visibleChars = 0;
            }

            update() {
                this.formProgress += 0.02;
                if (this.formProgress < 1) {
                    this.visibleChars = Math.floor(this.text.length * this.formProgress);
                } else {
                    this.visibleChars = this.text.length;
                    this.lifespan--;
                }
                this.opacity = this.lifespan / this.maxLifespan;
            }

            draw(ctx) {
                if (this.formProgress <= 0) return;

                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.font = `${this.fontSize}px 'STKaiti', 'KaiTi', 'æ¥·ä½“', serif`;
                ctx.fillStyle = this.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const visibleText = this.text.substring(0, this.visibleChars);
                ctx.fillText(visibleText, this.pos.x, this.pos.y);

                ctx.restore();
            }
        }

        class BlessingDanmaku {
            constructor(text) {
                this.text = text;
                this.x = -300;
                this.y = Math.random() * window.innerHeight * 0.6 + 50;
                this.speed = Math.random() * 1 + 0.5;
                this.opacity = 0.8;
                this.fontSize = Math.random() * 8 + 14;
                this.color = `rgba(255, ${200 + Math.random() * 55}, ${Math.random() * 100}, ${this.opacity})`;
                this.absorbed = false;
            }

            update() {
                if (!this.absorbed) {
                    this.x += this.speed;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.font = `${this.fontSize}px 'STKaiti', 'KaiTi', 'æ¥·ä½“', serif`;
                ctx.fillStyle = this.color;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }

            isOffScreen() {
                return this.x > window.innerWidth + 100;
            }
        }

        class Firework {
            constructor(x, targetY, textColor, blessing = null) {
                this.startX = x;
                this.startY = window.innerHeight;
                this.pos = new Vector2(x, window.innerHeight);
                this.targetY = targetY;
                this.textColor = textColor;
                this.isExploded = false;
                this.particles = [];
                this.textParticles = [];
                this.blessing = blessing;
                const blessingTexts = [
                    'æœˆäº®çš„ç›',
                    'è’åŸ',
                    'é‡å ',
                    'ç§è¯­',
                    'å›å£°',
                    'ç¥ç€',
                    'ç†„ç­',
                    'æ¼«æ¸¸',
                    'ç¬æ—¶',
                    'è“è‰²çš„å¿§éƒ',
                    'æ½®æ±',
                    'æ‚¬æµ®',
                    'é¢—ç²’',
                    'é™è½',
                    'é€æ˜',
                    'ç¼éš™',
                    'æ—·é‡',
                    'å‘¼å¸',
                    'é•€é‡‘',
                    'å¹¸å­˜'
                ];
                this.text = blessing ? blessing : blessingTexts[Math.floor(Math.random() * blessingTexts.length)];
                this.speed = Math.random() * 3 + 8;
                this.trail = [];
                this.shouldBeLobster = Math.random() < 0.5; // 50% æ¦‚ç‡ç”Ÿæˆé¾™è™¾å½¢çŠ¶
            }

            update() {
                if (!this.isExploded) {
                    this.pos.y -= this.speed;
                    this.trail.push({
                        pos: this.pos.clone(),
                        life: 20
                    });

                    if (this.pos.y <= this.targetY) {
                        this.explode();
                    }

                    this.trail = this.trail.filter(t => {
                        t.life--;
                        return t.life > 0;
                    });
                } else {
                    this.particles = this.particles.filter(p => {
                        p.update();
                        return !p.isDead();
                    });

                    this.textParticles = this.textParticles.filter(tp => {
                        tp.update();
                        return !tp.isDead();
                    });
                }
            }

            explode() {
                this.isExploded = true;

                if (this.shouldBeLobster) {
                    // é¾™è™¾ä¸“å±é¢œè‰² - æ›´é²œè‰³çš„æ©™è‰²å’Œçº¢è‰²
                    const lobsterColors = [
                        'rgba(255, 100, 0, 1)',     // æ·±æ©™è‰²
                        'rgba(255, 150, 0, 1)',     // æ©™é»„è‰²
                        'rgba(255, 120, 50, 1)',    // çŠç‘šæ©™
                        'rgba(255, 200, 100, 1)',   // é‡‘é»„è‰²
                        'rgba(255, 80, 20, 1)',     // æ©™çº¢è‰²
                        'rgba(255, 60, 0, 1)',      // æ·±çº¢æ©™
                        'rgba(255, 180, 60, 1)'     // äº®æ©™è‰²
                    ];
                    console.log('ğŸ¦ ç”Ÿæˆé¾™è™¾å½¢çŠ¶çƒŸèŠ±ï¼');
                    // é¾™è™¾å½¢çŠ¶æœ‰æ›´å¤§æ›´å¯†é›†çš„ç²’å­
                    this.createLobsterShape(lobsterColors);
                } else {
                    // æ™®é€šçƒŸèŠ±å‡å°‘ç²’å­æ•°é‡åˆ°40ï¼Œè®©é¾™è™¾æ›´æ˜æ˜¾
                    const normalColors = [
                        'rgba(255, 100, 100, 1)',
                        'rgba(255, 215, 0, 1)',
                        'rgba(255, 200, 200, 1)',
                        'rgba(200, 150, 255, 1)'
                    ];
                    for (let i = 0; i < 40; i++) {
                        const angle = (Math.PI * 2 * i) / 40;
                        const vel = Math.random() * 8 + 2;
                        const vx = Math.cos(angle) * vel;
                        const vy = Math.sin(angle) * vel - 2;
                        const color = normalColors[Math.floor(Math.random() * normalColors.length)];
                        this.particles.push(new Particle(this.pos.x, this.pos.y, color, new Vector2(vx, vy)));
                    }
                }

                // åˆ›å»ºæ–‡å­—ç²’å­ - æ¯ä¸ªè¯è¯­å®Œæ•´æ˜¾ç¤ºï¼Œä¸æ‹†åˆ†å­—ç¬¦
                this.textParticles.push(new TextParticle(this.pos.x, this.pos.y, this.text, 32));
            }

            createLobsterShape(colors) {
                const centerX = this.pos.x;
                const centerY = this.pos.y;
                const scale = Math.random() * 40 + 70; // å¢å¤§é¾™è™¾å¤§å°ï¼ˆ70-110ä¹‹é—´ï¼‰

                // é¾™è™¾è½®å»“ç‚¹æ•°ç»„ - ä»å°¾éƒ¨åˆ°é’³å­çš„è¿ç»­è·¯å¾„
                const lobsterPoints = [
                    // å°¾å·´ï¼ˆæ‰‡å½¢ï¼‰- ä»ä¸­é—´å¼€å§‹
                    {x: 0, y: -0.8},      // å°¾å°–ä¸­å¿ƒ
                    {x: -0.2, y: -0.75},  {x: 0.2, y: -0.75},  // å°¾å°–ä¸¤ä¾§
                    {x: -0.4, y: -0.6},   {x: 0.4, y: -0.6},   // å°¾å·´æ‰©å±•
                    {x: -0.5, y: -0.4},   {x: 0.5, y: -0.4},   // å°¾å·´åŸºéƒ¨

                    // èº«ä½“ä¸­éƒ¨ï¼ˆæ¤­åœ†å½¢ï¼‰
                    {x: -0.45, y: -0.2},  {x: 0.45, y: -0.2},
                    {x: -0.48, y: 0},     {x: 0.48, y: 0},
                    {x: -0.45, y: 0.2},   {x: 0.45, y: 0.2},
                    {x: -0.4, y: 0.4},    {x: 0.4, y: 0.4},

                    // å¤´éƒ¨ï¼ˆè¾ƒå¤§ï¼‰
                    {x: -0.35, y: 0.6},   {x: 0.35, y: 0.6},
                    {x: -0.3, y: 0.7},    {x: 0.3, y: 0.7},

                    // è§¦è§’
                    {x: -0.2, y: 0.75},   {x: 0.2, y: 0.75},
                    {x: -0.25, y: 0.82},  {x: 0.25, y: 0.82},

                    // èº«ä½“ä¸é’³å­è¿æ¥å¤„
                    {x: -0.15, y: 0.78},  {x: 0.15, y: 0.78},

                    // å·¦é’³å­ï¼ˆå¤§é’³å­ï¼‰
                    {x: -0.25, y: 0.75},  // é’³å­åŸºéƒ¨
                    {x: -0.4, y: 0.7},    // é’³å­ç¬¬ä¸€èŠ‚
                    {x: -0.55, y: 0.65},  // é’³å­ç¬¬äºŒèŠ‚
                    {x: -0.7, y: 0.6},    // é’³å­æ‰‹æŒ
                    {x: -0.85, y: 0.55},  // ä¸‹é’³æŒ‡
                    {x: -0.75, y: 0.5},   // ä¸Šé’³æŒ‡

                    // å³é’³å­
                    {x: 0.25, y: 0.75},
                    {x: 0.4, y: 0.7},
                    {x: 0.55, y: 0.65},
                    {x: 0.7, y: 0.6},
                    {x: 0.85, y: 0.55},
                    {x: 0.75, y: 0.5},

                    // è…¿éƒ¨ï¼ˆèº«ä½“ä¸¤ä¾§ï¼‰
                    // å·¦ä¾§è…¿
                    {x: -0.42, y: -0.1},  {x: -0.55, y: 0},
                    {x: -0.45, y: 0.1},   {x: -0.58, y: 0.2},
                    {x: -0.44, y: 0.3},   {x: -0.57, y: 0.4},

                    // å³ä¾§è…¿
                    {x: 0.42, y: -0.1},   {x: 0.55, y: 0},
                    {x: 0.45, y: 0.1},    {x: 0.58, y: 0.2},
                    {x: 0.44, y: 0.3},    {x: 0.57, y: 0.4}
                ];

                // åˆ›å»ºé¾™è™¾è½®å»“ç²’å­ - æ›´å¤§æ›´äº®
                lobsterPoints.forEach((point, index) => {
                    const x = centerX + point.x * scale;
                    const y = centerY + point.y * scale;
                    const color = colors[Math.floor(Math.random() * colors.length)];

                    // ç»™ç²’å­ä¸€äº›éšæœºçš„é€Ÿåº¦ï¼Œä½¿å…¶æœ‰çˆ†ç‚¸æ•ˆæœ
                    const angle = Math.atan2(point.y, point.x) || Math.random() * Math.PI * 2;
                    const vel = Math.random() * 3 + 2; // ç¨å¾®æ…¢ä¸€ç‚¹ï¼Œå½¢çŠ¶æ›´æ˜æ˜¾
                    const vx = Math.cos(angle) * vel;
                    const vy = Math.sin(angle) * vel - 1;

                    // é¾™è™¾ç²’å­æ›´å¤§ï¼ˆ3-5åƒç´ ï¼‰ä¸”ç”Ÿå‘½å‘¨æœŸæ›´é•¿
                    const particleSize = Math.random() * 2 + 3;
                    this.particles.push(new Particle(x, y, color, new Vector2(vx, vy), 200, particleSize));
                });

                // é¢å¤–æ·»åŠ æ›´å¤šå†…éƒ¨å¡«å……ç²’å­ï¼Œè®©é¾™è™¾æ›´é¥±æ»¡ - ä½¿ç”¨æ›´å¤§çš„ç²’å­
                for (let i = 0; i < 80; i++) {
                    const t = Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * 0.6;

                    let x = centerX + Math.cos(angle) * r * scale;
                    let y = centerY + Math.sin(angle) * r * scale * 0.8; // ç¨å¾®å‹æ‰ï¼Œæ›´åƒé¾™è™¾èº«ä½“

                    // é™åˆ¶åœ¨é¾™è™¾å½¢çŠ¶å†…
                    if (Math.abs(Math.sin(angle)) > 0.7) {
                        // ä¸Šä¸‹åŒºåŸŸé™åˆ¶æ›´å¤š
                        y = centerY + Math.sin(angle) * r * scale * 0.6;
                    }

                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const vx = Math.cos(angle) * (Math.random() * 4 + 2);
                    const vy = Math.sin(angle) * (Math.random() * 4 + 2) - 2;

                    // å†…éƒ¨å¡«å……ç²’å­ä¹Ÿå¤§ä¸€ç‚¹ï¼ˆ2-4åƒç´ ï¼‰
                    const particleSize = Math.random() * 2 + 2;
                    this.particles.push(new Particle(x, y, color, new Vector2(vx, vy), 180, particleSize));
                }
            }

            draw(ctx) {
                if (!this.isExploded) {
                    // ç»˜åˆ¶è½¨è¿¹
                    this.trail.forEach((t, i) => {
                        ctx.globalAlpha = t.life / 20;
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(t.pos.x, t.pos.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1;

                    // ç»˜åˆ¶ä¸Šå‡çš„å…‰ç‚¹
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    this.particles.forEach(p => p.draw(ctx));
                    this.textParticles.forEach(tp => tp.draw(ctx));
                }
            }

            isDead() {
                return this.isExploded && this.particles.length === 0 && this.textParticles.length === 0;
            }
        }

        class AudioManager {
            constructor() {
                this.bgMusic = null;
                this.noise = null;
                this.enabled = false;
            }

            init() {
                // é¢„ç•™éŸ³é¢‘æ¥å£ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥æ¥å…¥çœŸå®çš„éŸ³é¢‘æ–‡ä»¶
                console.log('éŸ³é¢‘æ¨¡å—åˆå§‹åŒ–');
            }

            playBackground() {
                console.log('æ’­æ”¾Lo-fièƒŒæ™¯éŸ³ä¹');
            }

            playNoise() {
                console.log('æ’­æ”¾é­ç‚®å£°éŸ³');
            }

            stop() {
                console.log('åœæ­¢æ‰€æœ‰éŸ³é¢‘');
            }
        }

        class WebhookManager {
            constructor(danmakuSystem) {
                this.danmakuSystem = danmakuSystem;
                this.mockBlessings = [
                    'æœˆäº®çš„ç›',
                    'è’åŸ',
                    'é‡å ',
                    'ç§è¯­',
                    'å›å£°',
                    'ç¥ç€',
                    'ç†„ç­',
                    'æ¼«æ¸¸',
                    'ç¬æ—¶',
                    'è“è‰²çš„å¿§éƒ',
                    'æ½®æ±',
                    'æ‚¬æµ®',
                    'é¢—ç²’',
                    'é™è½',
                    'é€æ˜',
                    'ç¼éš™',
                    'æ—·é‡',
                    'å‘¼å¸',
                    'é•€é‡‘',
                    'å¹¸å­˜'
                ];
            }

            // æ¨¡æ‹Ÿæ¥æ”¶ç¥ç¦
            simulateIncomingBlessing() {
                setTimeout(() => {
                    const blessing = this.mockBlessings[Math.floor(Math.random() * this.mockBlessings.length)];
                    this.danmakuSystem.addBlessing(blessing);
                    this.simulateIncomingBlessing();
                }, Math.random() * 15000 + 10000); // æ¯10-25ç§’æ¨¡æ‹Ÿä¸€ä¸ªç¥ç¦
            }
        }

        class DanmakuSystem {
            constructor(fireworkSystem) {
                this.blessings = [];
                this.fireworkSystem = fireworkSystem;
            }

            addBlessing(text) {
                this.blessings.push(new BlessingDanmaku(text));
            }

            update() {
                this.blessings = this.blessings.filter(blessing => {
                    blessing.update();

                    // æ£€æŸ¥å¼¹å¹•æ˜¯å¦è¢«çƒŸèŠ±å¸æ”¶
                    if (!blessing.absorbed && Math.random() < 0.005) {
                        blessing.absorbed = true;
                        this.fireworkSystem.launchBlessingFirework(blessing.text);
                        return false;
                    }

                    return !blessing.isOffScreen();
                });
            }

            draw(ctx) {
                this.blessings.forEach(blessing => blessing.draw(ctx));
            }
        }

        class FireworkSystem {
            constructor() {
                this.fireworks = [];
                this.autoLaunchInterval = null;
            }

            launchRandom() {
                const x = Math.random() * (window.innerWidth - 200) + 100;
                const targetY = Math.random() * window.innerHeight * 0.4 + 100;
                this.fireworks.push(new Firework(x, targetY, '#ffd700'));
            }

            launchBlessingFirework(blessing) {
                const x = Math.random() * (window.innerWidth - 200) + 100;
                const targetY = Math.random() * window.innerHeight * 0.4 + 100;
                this.fireworks.push(new Firework(x, targetY, '#ff6b6b', blessing));
            }

            startAutoLaunch() {
                this.autoLaunchInterval = setInterval(() => {
                    this.launchRandom();
                }, 3000);

                // æ¯20ç§’ï¼Œæ‰€æœ‰20ä¸ªè¯—æ„æ„è±¡ä¸€èµ·ç»½æ”¾ï¼ˆè¯—æ„çƒŸèŠ±é£æš´ï¼‰
                setInterval(() => {
                    this.launchAllPoetryFireworks();
                }, 20000);
            }

            launchAllPoetryFireworks() {
                const poetryTexts = [
                    'æœˆäº®çš„ç›', 'è’åŸ', 'é‡å ', 'ç§è¯­', 'å›å£°',
                    'ç¥ç€', 'ç†„ç­', 'æ¼«æ¸¸', 'ç¬æ—¶', 'è“è‰²çš„å¿§éƒ',
                    'æ½®æ±', 'æ‚¬æµ®', 'é¢—ç²’', 'é™è½', 'é€æ˜',
                    'ç¼éš™', 'æ—·é‡', 'å‘¼å¸', 'é•€é‡‘', 'å¹¸å­˜'
                ];

                // 20ä¸ªçƒŸèŠ±åœ¨å±å¹•ä¸åŒä½ç½®åŒæ—¶å‡ç©º
                for (let i = 0; i < poetryTexts.length; i++) {
                    // åˆ†æˆ4è¡Œï¼Œæ¯è¡Œ5ä¸ª
                    const row = Math.floor(i / 5);
                    const col = i % 5;

                    // è®¡ç®—æ¯ä¸ªçƒŸèŠ±çš„ä½ç½®
                    const paddingX = window.innerWidth * 0.1;
                    const paddingY = window.innerHeight * 0.1;
                    const spacingX = (window.innerWidth - paddingX * 2) / 5;
                    const spacingY = (window.innerHeight * 0.4 - paddingY * 2) / 4;

                    const x = paddingX + col * spacingX + Math.random() * 80 - 40;
                    const y = paddingY + row * spacingY + Math.random() * window.innerHeight * 0.6;

                    // å»¶è¿Ÿå‘å°„ï¼Œåˆ›é€ æ³¢æµªæ•ˆæœ
                    setTimeout(() => {
                        this.fireworks.push(new Firework(x, y, '#ff6b6b', poetryTexts[i]));
                        console.log(`ğŸ† è¯—æ„çƒŸèŠ±ç»½æ”¾: ${poetryTexts[i]}`);
                    }, i * 150); // æ¯ä¸ªçƒŸèŠ±å»¶è¿Ÿ150msï¼Œåˆ›é€ æ³¢æµªæ„Ÿ
                }

                console.log('ğŸ‡ è¯—æ„çƒŸèŠ±é£æš´ï¼20ä¸ªè¯—æ„æ„è±¡åŒæ—¶å‡ç©ºï¼');
            }

            update() {
                this.fireworks = this.fireworks.filter(fw => {
                    fw.update();
                    return !fw.isDead();
                });
            }

            draw(ctx) {
                this.fireworks.forEach(fw => fw.draw(ctx));
            }
        }

        // ä¸»åº”ç”¨
        class App {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');

                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.audioManager = new AudioManager();
                this.fireworkSystem = new FireworkSystem();
                this.danmakuSystem = new DanmakuSystem(this.fireworkSystem);
                this.webhookManager = new WebhookManager(this.danmakuSystem);

                this.setupEventListeners();
                this.start();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                document.getElementById('sendButton').addEventListener('click', () => {
                    const input = document.getElementById('blessingText');
                    const text = input.value.trim();
                    if (text) {
                        this.danmakuSystem.addBlessing(text);
                        input.value = '';
                    }
                });

                document.getElementById('blessingText').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('sendButton').click();
                    }
                });

                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    if (y > window.innerHeight * 0.6) {
                        const targetY = window.innerHeight * 0.2 + Math.random() * window.innerHeight * 0.3;
                        this.fireworkSystem.fireworks.push(new Firework(x, targetY, '#ffd700'));
                    }
                });
            }

            start() {
                this.fireworkSystem.startAutoLaunch();
                this.webhookManager.simulateIncomingBlessing();

                // æç¤ºè¯—æ„çƒŸèŠ±é£æš´å³å°†å¼€å§‹
                setTimeout(() => {
                    console.log('ğŸ‡ å‡†å¤‡è¿æ¥è¯—æ„çƒŸèŠ±é£æš´ï¼æ¯20ç§’ï¼Œæ‰€æœ‰20ä¸ªè¯—æ„æ„è±¡å°†ä¸€èµ·ç»½æ”¾ï¼');
                }, 3000);

                this.animate();
            }

            animate() {
                // åˆ›å»ºæ®‹å½±æ•ˆæœ
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // æ›´æ–°å’Œç»˜åˆ¶ç³»ç»Ÿ
                this.fireworkSystem.update();
                this.danmakuSystem.update();

                this.fireworkSystem.draw(this.ctx);
                this.danmakuSystem.draw(this.ctx);

                requestAnimationFrame(() => this.animate());
            }
        }

        // å¯åŠ¨åº”ç”¨
        window.addEventListener('load', () => {
            new App();
        });
    </script>
</body>
</html>